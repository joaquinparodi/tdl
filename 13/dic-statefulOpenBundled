local NewDicc in
   fun {NewDicc} 
      C = {NewCell nil}
      proc {Put Key Value}
	 case @C of nil then C := tree(Key Value {NewDicc} {NewDicc})
	 [] tree(K V Left Right) then
	    if(Value > V) then
	       {Right.put Key Value}
	    else
	       {Left.put Key Value}
	    end
	 end
      end
      fun {Get Key}
	 case @C of nil then nil
	 [] tree(K Value _ _) andthen Key == K then Value
	 [] tree(K _ L _) andthen Key < K then
	    {L.get Key}
	 [] tree(K _ _ R) andthen Key > K then
	    {R.get Key}
	 end
      end
      fun {GetKeyValueList}
	 case @C 
	 of 
	  tree(Key Value nil nil) then tuple(Key Value)
	 [] tree(Key Value Left nil) then {List.append {Left.getKeyValueList} tuple(Key Value)}
	 [] tree(Key Value nil Right) then tuple(Key Value)|{Right.getKeyValueList}
	 [] tree(Key Value Left Right) then {List.append {Left.getKeyValueList} tuple(Key Value)|{Right.getKeyValueList}}
	 else nil
	 end
	 
      end
      
      fun {Equals Dict2}
	 local L1 L2 in
	    L1 = {GetKeyValueList}
	    L2 = {Dict2.getKeyValueList}
	    {EqualsLists L1 L2}
	 end
      end

      fun {EqualsLists L1 L2}
	 case L1 of nil then
	    case L2 of nil then true
	    [] H|T then false
	    end
	 [] H|T then
	    case L2 of nil then false
	    [] H2|T2 then
	       if H.2 == H2.2 andthen  H.1 == H2.1 then
		  {EqualsLists T T2}
	       else
		  false
	       end
	    else
	       false
	    end
	 else
	    false
	 end
      end
   in
      dicc(new:NewDicc get:Get put:Put equals:Equals getKeyValueList:GetKeyValueList)
   end
   
end
